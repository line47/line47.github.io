<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Step 4: Halftone + Animated LINE 47</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: white;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    video {
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="visualizer"></canvas>
  <video id="webcam" autoplay muted playsinline></video>

  <script>
    const canvas = document.getElementById("visualizer");
    const ctx = canvas.getContext("2d");
    const video = document.getElementById("webcam");
    const offscreen = document.createElement("canvas");
    const offCtx = offscreen.getContext("2d");

    let videoAspectRatio = 16 / 9; // Default fallback


    let midiValues = [127, 127, ...new Array(14).fill(0)]; 
   // Detect phone (mobile) and set CC34 to 50
    const isPhone = /Mobi|Android/i.test(navigator.userAgent) || window.innerWidth < 480;
    if (isPhone) {
    midiValues[1] = 50; // CC34 - Grid Resolution
    }
    let backgroundShapes = [];
    const phrase = "LINE 47";
    let revealTimers = new Array(phrase.length).fill(0);
    let shuffledIndices = [...Array(phrase.length).keys()].sort(() => Math.random() - 0.5);
    let audioLevel = 0;

    setInterval(() => {
      shuffledIndices = [...Array(phrase.length).keys()].sort(() => Math.random() - 0.5);
    }, 4000);

    function resizeCanvas() {
  const windowAspect = window.innerWidth / window.innerHeight;

  if (windowAspect > videoAspectRatio) {
    // Window is wider than video: match height, center horizontally
    canvas.height = window.innerHeight;
    canvas.width = canvas.height * videoAspectRatio;
  } else {
    // Window is taller than video: match width, center vertically
    canvas.width = window.innerWidth;
    canvas.height = canvas.width / videoAspectRatio;
  }

  canvas.style.position = "absolute";
  canvas.style.left = ((window.innerWidth - canvas.width) / 2) + "px";
  canvas.style.top = ((window.innerHeight - canvas.height) / 2) + "px";

  generateShapes();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then((stream) => {
      video.srcObject = stream;
      video.addEventListener("loadedmetadata", () => {
        video.play();
        videoAspectRatio = video.videoWidth / video.videoHeight;
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const audioSource = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        audioSource.connect(analyser);

        function updateAudio() {
          analyser.getByteFrequencyData(dataArray);
          audioLevel = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
          requestAnimationFrame(updateAudio);
        }

        updateAudio();
        requestAnimationFrame(draw);
      });
    }).catch((err) => {
      alert("Webcam error: " + err.message);
    });

    function generateShapes() {
      const count = 3 + Math.floor(Math.random() * 2);
      backgroundShapes = [];

      for (let i = 0; i < count; i++) {
        const points = [];
        const numPoints = 4 + Math.floor(Math.random() * 6);
        const centerX = Math.random() * canvas.width;
        const centerY = Math.random() * canvas.height;
        const baseRadius = 150 + Math.random() * 200;
        const angleMod = (midiValues[2] / 127) * 0.8;

        for (let j = 0; j < numPoints; j++) {
          const angle = (j / numPoints) * 2 * Math.PI + (Math.random() - 0.5) * angleMod;
          const rMod = baseRadius * (0.7 + Math.random() * 0.6);
          const x = centerX + Math.cos(angle) * rMod;
          const y = centerY + Math.sin(angle) * rMod;
          points.push({ x, y });
        }

        backgroundShapes.push(points);
      }
    }

    function drawBackgroundShapes() {
      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0.075)";
      ctx.strokeStyle = "rgba(0, 0, 0, 0.075)";
      ctx.lineWidth = 1;

      backgroundShapes.forEach(s => {
        ctx.beginPath();
        ctx.moveTo(s[0].x, s[0].y);
        for (let i = 1; i < s.length; i++) {
          ctx.lineTo(s[i].x, s[i].y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      });

      ctx.restore();
    }

    function drawHalftone() {
      const resCC = midiValues[1];
      const cols = 40 + Math.floor((resCC / 127) * 120);
      const aspect = canvas.width / canvas.height;
      const rows = Math.floor(cols / aspect);

      offscreen.width = cols;
      offscreen.height = rows;

      offCtx.drawImage(video, 0, 0, cols, rows);
      const imageData = offCtx.getImageData(0, 0, cols, rows).data;

      const dotSpacingX = canvas.width / cols;
      const dotSpacingY = canvas.height / rows;

      const sizeCC = midiValues[0];
      const dotScale = 0.5 + (sizeCC / 127) * 1.5;

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const i = (y * cols + x) * 4;
          const r = imageData[i];
          const g = imageData[i + 1];
          const b = imageData[i + 2];
          const brightness = (r + g + b) / 3;

          const size = (1 - brightness / 255) * Math.min(dotSpacingX, dotSpacingY) * 0.5 * dotScale;
          const cx = x * dotSpacingX;
          const cy = y * dotSpacingY;

          ctx.fillStyle = "black";
          ctx.fillRect(cx - size / 2, cy - size / 2, size, size);
        }
      }
    }

    function drawLine47Text(time) {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = "80px monospace";

      const amplitudeThreshold = 30;
      const audioActive = audioLevel > amplitudeThreshold;

      // Randomly reveal 1–2 characters when audio is active
      if (audioActive) {
        for (let j = 0; j < 2; j++) {
          const index = shuffledIndices[Math.floor(Math.random() * shuffledIndices.length)];
          if (Math.random() < 0.25) {
            revealTimers[index] = 20;
          }
        }
      }

      for (let i = 0; i < phrase.length; i++) {
        const x = (i - phrase.length / 2) * 50;
        const y = 0;

        if (revealTimers[i] > 0) {
          revealTimers[i]--;
          ctx.fillStyle = "black";
          ctx.fillText(phrase[i], x, y);
        } else {
          // Dot matrix style grid of small black squares
          const dotSize = 3;
          const cols = 4;
          const rows = 8;
          ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
              const dx = x - (cols * dotSize) / 2 + col * dotSize;
              const dy = y - (rows * dotSize) / 2 + row * dotSize;
              ctx.fillRect(dx, dy, dotSize - 1, dotSize - 1);
            }
          }
        }
      }

      ctx.restore();
    }

    function draw(time = 0) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        drawBackgroundShapes();
        drawHalftone();
        drawLine47Text(time);
      }

      ctx.save();
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, 220, 60);
      ctx.font = "14px monospace";
      ctx.fillStyle = "#444";
      ctx.fillText("CC33_Dot_Size: " + midiValues[0], 20, 20);
      ctx.fillText("CC34_Grid_Res: " + midiValues[1], 20, 40);
      ctx.restore();

      requestAnimationFrame(draw);
    }

    function onMIDIMessage(event) {
      const [status, cc, value] = event.data;
      if (status === 176 && cc >= 33 && cc <= 48) {
        midiValues[cc - 33] = value;
      }
    }

    function onMIDISuccess(midiAccess) {
      for (const input of midiAccess.inputs.values()) {
        input.onmidimessage = onMIDIMessage;
      }
      console.log("✅ MIDI connected");
    }

    function onMIDIFailure() {
      console.warn("❌ MIDI access failed");
    }

    navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
  </script>
</body>
</html>
