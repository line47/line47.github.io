<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Step 4: Halftone + Animated LINE 47</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: white;
      overflow: hidden;
    }

    canvas {
      display: block;
      top: 0 !important;
    }

    video {
      display: none;
    }
  </style>
</head>

<body>
  <canvas id="visualizer"></canvas>
  <video id="webcam" autoplay muted playsinline></video>

  <script>



    const canvas = document.getElementById("visualizer");
    const ctx = canvas.getContext("2d");
    const video = document.getElementById("webcam");
    const offscreen = document.createElement("canvas");
    const offCtx = offscreen.getContext("2d");

    let videoAspectRatio = 16 / 9; // Default fallback


    let midiValues = [127, 127, ...new Array(14).fill(0)];
    // Detect phone (mobile) and set CC34 to 50
    const isPhone = /Mobi|Android/i.test(navigator.userAgent) || window.innerWidth < 480;
    if (isPhone) {
      midiValues[1] = 0; // CC34 - Grid Resolution
    }
    let backgroundShapes = [];
    const phrase = "AS YOU WERE MEANT TO GO ON";
    let revealTimers = new Array(phrase.length).fill(0);
    let shuffledIndices = [...Array(phrase.length).keys()].sort(() => Math.random() - 0.5);
    let audioLevel = 0;

    const wordsPerLine = 2 + Math.floor(Math.random() * 4); // 2 to 5 words per line
    const avgWordLength = 5.5; // Adjust based on your phrase style
    const maxCharsPerLine = Math.floor(wordsPerLine * avgWordLength);



    const lines = wrapPhraseIntoLines(phrase, maxCharsPerLine);

    setInterval(() => {
      shuffledIndices = [...Array(phrase.length).keys()].sort(() => Math.random() - 0.5);
    }, 4000);

    function resizeCanvas() {
      // Detect if it's a phone
      const isPhone = /Mobi|Android/i.test(navigator.userAgent) || window.innerWidth < 600;

      // Use portrait 9:16 ratio on phones, otherwise use video aspect
      const aspectRatio = isPhone ? 9 / 16 : videoAspectRatio;

      const windowAspect = window.innerWidth / window.innerHeight;

      if (windowAspect > aspectRatio) {
        // Window is wider than target aspect: match height
        canvas.height = window.innerHeight;
        canvas.width = canvas.height * aspectRatio;
      } else {
        // Window is taller than target aspect: match width
        canvas.width = window.innerWidth;
        canvas.height = canvas.width / aspectRatio;
      }

      canvas.style.position = "absolute";
      canvas.style.left = ((window.innerWidth - canvas.width) / 2) + "px";
      canvas.style.top = ((window.innerHeight - canvas.height) / 2) + "px";

      generateShapes();
    }



    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then((stream) => {
      video.srcObject = stream;
      video.addEventListener("loadedmetadata", () => {
        video.play();
        if (!/Mobi|Android/i.test(navigator.userAgent) && window.innerWidth >= 600) {
          videoAspectRatio = video.videoWidth / video.videoHeight;
        }
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const audioSource = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        audioSource.connect(analyser);

        function updateAudio() {
          analyser.getByteFrequencyData(dataArray);
          audioLevel = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
          requestAnimationFrame(updateAudio);
        }

        updateAudio();
        requestAnimationFrame(draw);
      });
    }).catch((err) => {
      alert("Webcam error: " + err.message);
    });

    function generateShapes() {
      const count = 3 + Math.floor(Math.random() * 2);
      backgroundShapes = [];

      for (let i = 0; i < count; i++) {
        const points = [];
        const numPoints = 4 + Math.floor(Math.random() * 6);
        const centerX = Math.random() * canvas.width;
        const centerY = Math.random() * canvas.height;
        const baseRadius = 150 + Math.random() * 200;
        const angleMod = (midiValues[2] / 127) * 0.8;

        for (let j = 0; j < numPoints; j++) {
          const angle = (j / numPoints) * 2 * Math.PI + (Math.random() - 0.5) * angleMod;
          const rMod = baseRadius * (0.7 + Math.random() * 0.6);
          const x = centerX + Math.cos(angle) * rMod;
          const y = centerY + Math.sin(angle) * rMod;
          points.push({ x, y });
        }

        backgroundShapes.push(points);
      }
    }

    function drawBackgroundShapes() {
      ctx.save();
      ctx.fillStyle = "rgba(0, 0, 0, 0.075)";
      ctx.strokeStyle = "rgba(0, 0, 0, 0.075)";
      ctx.lineWidth = 1;

      backgroundShapes.forEach(s => {
        ctx.beginPath();
        ctx.moveTo(s[0].x, s[0].y);
        for (let i = 1; i < s.length; i++) {
          ctx.lineTo(s[i].x, s[i].y);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      });

      ctx.restore();
    }

    function drawHalftone() {
      const resCC = midiValues[1];
      const cols = 40 + Math.floor((resCC / 127) * 120);
      const aspect = canvas.width / canvas.height;
      const rows = Math.floor(cols / aspect);

      offscreen.width = cols;
      offscreen.height = rows;

      // Clear offscreen before drawing
      offCtx.clearRect(0, 0, cols, rows);

      // Calculate video draw size to preserve aspect ratio
      const videoAR = video.videoWidth / video.videoHeight;
      const targetAR = cols / rows;

      let sx = 0, sy = 0, sw = video.videoWidth, sh = video.videoHeight;

      if (videoAR > targetAR) {
        // Video is wider: crop sides
        sw = video.videoHeight * targetAR;
        sx = (video.videoWidth - sw) / 2;
      } else {
        // Video is taller: crop top/bottom
        sh = video.videoWidth / targetAR;
        sy = (video.videoHeight - sh) / 2;
      }

      // Draw the cropped video into offscreen canvas
      offCtx.drawImage(video, sx, sy, sw, sh, 0, 0, cols, rows);

      const imageData = offCtx.getImageData(0, 0, cols, rows).data;
      const dotSpacingX = canvas.width / cols;
      const dotSpacingY = canvas.height / rows;

      const sizeCC = midiValues[0];
      const dotScale = 0.5 + (sizeCC / 127) * 1.5;

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const i = (y * cols + x) * 4;
          const r = imageData[i];
          const g = imageData[i + 1];
          const b = imageData[i + 2];
          const brightness = (r + g + b) / 3;

          const size = (1 - brightness / 255) * Math.min(dotSpacingX, dotSpacingY) * 0.5 * dotScale;
          const cx = x * dotSpacingX;
          const cy = y * dotSpacingY;

          ctx.fillStyle = "black";
          ctx.fillRect(cx - size / 2, cy - size / 2, size, size);
        }
      }
    }


    function getResponsiveFontSize() {
      return Math.floor(canvas.width * 0.06); // 6% of canvas width
    }
    function getResponsiveLetterSpacing() {
      return canvas.width * 0.04; // 3% of canvas width per letter
    }

    function wrapPhraseIntoLines(phrase, maxCharsPerLine = 8) {
      const words = phrase.split(" ");
      const lines = [];
      let currentLine = "";

      for (let word of words) {
        if ((currentLine + word).length <= maxCharsPerLine) {
          currentLine += (currentLine ? " " : "") + word;
        } else {
          lines.push(currentLine);
          currentLine = word;
        }
      }
      if (currentLine) lines.push(currentLine);
      return lines;
    }

    function drawLine47Text(time) {
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      ctx.save();
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";

      const fontSize = getResponsiveFontSize();
      const spacing = getResponsiveLetterSpacing();
      ctx.font = `${fontSize}px monospace`;

      const amplitudeThreshold = 50;
      const audioActive = audioLevel > amplitudeThreshold;

      // Randomly reveal 1–2 characters when audio is active
      if (audioActive) {
        for (let j = 0; j < 8; j++) {
          const index = shuffledIndices[Math.floor(Math.random() * shuffledIndices.length)];
          if (Math.random() < 0.25) {
            revealTimers[index] = 80;
          }
        }
      }

      let charIndex = 0;
      const lineHeight = fontSize * 1.2;
      const totalHeight = lines.length * lineHeight;
      const startY = centerY - totalHeight / 2 + lineHeight / 2;

      lines.forEach((line, lineNum) => {
        const y = startY + lineNum * lineHeight;
        const offsetX = (line.length / 2) * spacing;

        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          const x = centerX + (i - line.length / 2) * spacing;

          if (char === " ") {
            continue; // Don't draw blocks for spaces
          }

          if (revealTimers[charIndex] > 0) {
            revealTimers[charIndex]--;
            ctx.fillStyle = "black";
            ctx.fillText(char, x, y);
          } else {
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillText("█", x, y);
          }

          charIndex++;
        }

        // Account for space between words in the global character index
        charIndex++; // For line breaks or spaces
      });

      ctx.restore();
    }




    function draw(time = 0) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        drawBackgroundShapes();
        drawHalftone();
        drawLine47Text(time);
      }

      ctx.save();
      ctx.fillStyle = "white";
      ctx.fillRect(0, 0, 220, 60);
      ctx.font = "14px monospace";
      ctx.fillStyle = "#444";
      ctx.fillText("CC33_Dot_Size: " + midiValues[0], 20, 20);
      ctx.fillText("CC34_Grid_Res: " + midiValues[1], 20, 40);
      ctx.restore();

      requestAnimationFrame(draw);
    }

    function onMIDIMessage(event) {
      const [status, cc, value] = event.data;
      if (status === 176 && cc >= 33 && cc <= 48) {
        midiValues[cc - 33] = value;
      }
    }

    function onMIDISuccess(midiAccess) {
      for (const input of midiAccess.inputs.values()) {
        input.onmidimessage = onMIDIMessage;
      }
      console.log("✅ MIDI connected");
    }

    function onMIDIFailure() {
      console.warn("❌ MIDI access failed");
    }

    navigator.requestMIDIAccess().then(onMIDISuccess, onMIDIFailure);
  </script>
</body>

</html>